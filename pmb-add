#!/usr/bin/env bash
# Bash3 Boilerplate. Copyright (c) 2014, kvz.io

set -o errexit
set -o pipefail
set -o nounset
############### end of Boilerplate

# script to add a Pi installation for multiboot using "pmb"
# Requires env vars
# * size - indicate the size of the resulting EXT4 partition
#          see the man page for sfdisk for units (e.g. size=10G)
# * device which holds a fresh unbooted RpiOS (or other) install
#   (e.g. device=/dev/sdb or device=/dev/mmcblk0)
# * path to compressed Debian image file

usage() {
    echo "device=/dev/sdb size=10G image=/path/to/compressed/image label=rpios $0 [settings_file] (for example)"
    echo "    -or-"
    echo "$0 [settings_file]"
    exit 1
}

# Check for first arg - settings file
if [[ -v 1 ]]
then
    if [ -e "$1" ]
    then
        echo sourcing "$1"
        # shellcheck disable=SC1090 # ShellCheck can't follow non-const...
        source "$1"
    else
        echo "$1 not found"
        usage
    fi
fi

# verify that needed CMD line args are provided
if [[ ! -v device ]] || [[ ! -v size ]] || [[ ! -v image ]]
then
    usage
fi

# Check for partition5 (Minimum partition when prepared, first Logical)

echo "============================================= find device (part5)"

if [ -e "${device}5" ]
then
    part5=${device}5
    partbase=${device}
elif [ -e "${device}p5" ]
then
    part5="${device}p5"
    partbase=${device}p
else
    echo "Can't find partition 5 on $device"
    echo "be sure to install and run 'pmb-init' before this script."
    usage
fi

echo "============================================= part5: $part5"

## Now loop to find the highest numbered partition.

for index in {5..20}
do    
  echo "$index"
  if [ ! -e "${partbase}$index" ]
  then
    break
  fi
done

newpart="$((index - 1))"
echo "next available partition is $index and new partition is $newpart"
echo "============================================= partitions to use: $index and $newpart"

## Create the new partition

sfdisk --delete "${device}" "${newpart}"
echo -e "type=L, size=${size}" | sfdisk -N "${newpart}" "${device}"

mkfs.ext4 "${partbase}${newpart}"

echo "============================================= recreate the filler"

echo -e 'type=L' | sfdisk -N "${index}" "${device}"

echo "============================================= decompress OS image"


# extract imstallation image

image_file=/tmp/$(basename -s .xz  "${image}")
unxz -k --stdout "${image}" >"$image_file"

# Create mount points
# Random dir name from
# https://stackoverflow.com/questions/2793812/generate-a-random-filename-in-unix-shell

boot_mnt=/tmp/$(date +%S%N)
mkdir "$boot_mnt"
root_mnt=/tmp/$(date +%S%N)
mkdir "$root_mnt"
target_mnt=/tmp/$(date +%S%N)
mkdir "$target_mnt"

# Configure and mount loop devices for the image to be installed

img_loop_dev=$(losetup --find --partscan --read-only --show "$image_file")
mount "${img_loop_dev}p1" "$boot_mnt"
mount "${img_loop_dev}p2" "$root_mnt"

# Mount the partition to "install" to.

mount "${partbase}${newpart}" "$target_mnt" 

# copy root files

rsync -a "$root_mnt"/ "$target_mnt"

# archive boot files

mkdir "$target_mnt"/root/root-backup/
tar cf "$target_mnt"/root/root-backup/install-backup.tar "$root_mnt"

### cleanup

umount "$boot_mnt" "$root_mnt" "$target_mnt"
losetup -d "$img_loop_dev"
rm -r "$boot_mnt" "$root_mnt" "$target_mnt" "${image_file}"

echo "$image successfully installed to ${partbase}${newpart}"
